// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'media_management.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

RadarrMediaManagementConfig _$RadarrMediaManagementConfigFromJson(
    Map<String, dynamic> json) {
  return _RadarrMediaManagementConfig.fromJson(json);
}

/// @nodoc
mixin _$RadarrMediaManagementConfig {
  int get id => throw _privateConstructorUsedError;
  bool get autoUnmonitorPreviouslyDownloadedMovies =>
      throw _privateConstructorUsedError;
  String? get recycleBin => throw _privateConstructorUsedError;
  int get recycleBinCleanupDays => throw _privateConstructorUsedError;
  RadarrProperDownloadType get downloadPropersAndRepacks =>
      throw _privateConstructorUsedError;
  bool get createEmptyMovieFolders => throw _privateConstructorUsedError;
  bool get deleteEmptyFolders => throw _privateConstructorUsedError;
  RadarrFileDateType get fileDate => throw _privateConstructorUsedError;
  RadarrRescanAfterRefreshType get rescanAfterRefresh =>
      throw _privateConstructorUsedError;
  bool get autoRenameFolders => throw _privateConstructorUsedError;
  bool get pathsDefaultStatic => throw _privateConstructorUsedError;
  bool get setPermissionsLinux => throw _privateConstructorUsedError;
  String? get chmodFolder => throw _privateConstructorUsedError;
  String? get chownGroup => throw _privateConstructorUsedError;
  bool get skipFreeSpaceCheckWhenImporting =>
      throw _privateConstructorUsedError;
  int get minimumFreeSpaceWhenImporting => throw _privateConstructorUsedError;
  bool get copyUsingHardlinks => throw _privateConstructorUsedError;
  bool get importExtraFiles => throw _privateConstructorUsedError;
  String? get extraFileExtensions => throw _privateConstructorUsedError;
  bool get enableMediaInfo => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RadarrMediaManagementConfigCopyWith<RadarrMediaManagementConfig>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RadarrMediaManagementConfigCopyWith<$Res> {
  factory $RadarrMediaManagementConfigCopyWith(
          RadarrMediaManagementConfig value,
          $Res Function(RadarrMediaManagementConfig) then) =
      _$RadarrMediaManagementConfigCopyWithImpl<$Res,
          RadarrMediaManagementConfig>;
  @useResult
  $Res call(
      {int id,
      bool autoUnmonitorPreviouslyDownloadedMovies,
      String? recycleBin,
      int recycleBinCleanupDays,
      RadarrProperDownloadType downloadPropersAndRepacks,
      bool createEmptyMovieFolders,
      bool deleteEmptyFolders,
      RadarrFileDateType fileDate,
      RadarrRescanAfterRefreshType rescanAfterRefresh,
      bool autoRenameFolders,
      bool pathsDefaultStatic,
      bool setPermissionsLinux,
      String? chmodFolder,
      String? chownGroup,
      bool skipFreeSpaceCheckWhenImporting,
      int minimumFreeSpaceWhenImporting,
      bool copyUsingHardlinks,
      bool importExtraFiles,
      String? extraFileExtensions,
      bool enableMediaInfo});
}

/// @nodoc
class _$RadarrMediaManagementConfigCopyWithImpl<$Res,
        $Val extends RadarrMediaManagementConfig>
    implements $RadarrMediaManagementConfigCopyWith<$Res> {
  _$RadarrMediaManagementConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? autoUnmonitorPreviouslyDownloadedMovies = null,
    Object? recycleBin = freezed,
    Object? recycleBinCleanupDays = null,
    Object? downloadPropersAndRepacks = null,
    Object? createEmptyMovieFolders = null,
    Object? deleteEmptyFolders = null,
    Object? fileDate = null,
    Object? rescanAfterRefresh = null,
    Object? autoRenameFolders = null,
    Object? pathsDefaultStatic = null,
    Object? setPermissionsLinux = null,
    Object? chmodFolder = freezed,
    Object? chownGroup = freezed,
    Object? skipFreeSpaceCheckWhenImporting = null,
    Object? minimumFreeSpaceWhenImporting = null,
    Object? copyUsingHardlinks = null,
    Object? importExtraFiles = null,
    Object? extraFileExtensions = freezed,
    Object? enableMediaInfo = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      autoUnmonitorPreviouslyDownloadedMovies: null ==
              autoUnmonitorPreviouslyDownloadedMovies
          ? _value.autoUnmonitorPreviouslyDownloadedMovies
          : autoUnmonitorPreviouslyDownloadedMovies // ignore: cast_nullable_to_non_nullable
              as bool,
      recycleBin: freezed == recycleBin
          ? _value.recycleBin
          : recycleBin // ignore: cast_nullable_to_non_nullable
              as String?,
      recycleBinCleanupDays: null == recycleBinCleanupDays
          ? _value.recycleBinCleanupDays
          : recycleBinCleanupDays // ignore: cast_nullable_to_non_nullable
              as int,
      downloadPropersAndRepacks: null == downloadPropersAndRepacks
          ? _value.downloadPropersAndRepacks
          : downloadPropersAndRepacks // ignore: cast_nullable_to_non_nullable
              as RadarrProperDownloadType,
      createEmptyMovieFolders: null == createEmptyMovieFolders
          ? _value.createEmptyMovieFolders
          : createEmptyMovieFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      deleteEmptyFolders: null == deleteEmptyFolders
          ? _value.deleteEmptyFolders
          : deleteEmptyFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDate: null == fileDate
          ? _value.fileDate
          : fileDate // ignore: cast_nullable_to_non_nullable
              as RadarrFileDateType,
      rescanAfterRefresh: null == rescanAfterRefresh
          ? _value.rescanAfterRefresh
          : rescanAfterRefresh // ignore: cast_nullable_to_non_nullable
              as RadarrRescanAfterRefreshType,
      autoRenameFolders: null == autoRenameFolders
          ? _value.autoRenameFolders
          : autoRenameFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      pathsDefaultStatic: null == pathsDefaultStatic
          ? _value.pathsDefaultStatic
          : pathsDefaultStatic // ignore: cast_nullable_to_non_nullable
              as bool,
      setPermissionsLinux: null == setPermissionsLinux
          ? _value.setPermissionsLinux
          : setPermissionsLinux // ignore: cast_nullable_to_non_nullable
              as bool,
      chmodFolder: freezed == chmodFolder
          ? _value.chmodFolder
          : chmodFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      chownGroup: freezed == chownGroup
          ? _value.chownGroup
          : chownGroup // ignore: cast_nullable_to_non_nullable
              as String?,
      skipFreeSpaceCheckWhenImporting: null == skipFreeSpaceCheckWhenImporting
          ? _value.skipFreeSpaceCheckWhenImporting
          : skipFreeSpaceCheckWhenImporting // ignore: cast_nullable_to_non_nullable
              as bool,
      minimumFreeSpaceWhenImporting: null == minimumFreeSpaceWhenImporting
          ? _value.minimumFreeSpaceWhenImporting
          : minimumFreeSpaceWhenImporting // ignore: cast_nullable_to_non_nullable
              as int,
      copyUsingHardlinks: null == copyUsingHardlinks
          ? _value.copyUsingHardlinks
          : copyUsingHardlinks // ignore: cast_nullable_to_non_nullable
              as bool,
      importExtraFiles: null == importExtraFiles
          ? _value.importExtraFiles
          : importExtraFiles // ignore: cast_nullable_to_non_nullable
              as bool,
      extraFileExtensions: freezed == extraFileExtensions
          ? _value.extraFileExtensions
          : extraFileExtensions // ignore: cast_nullable_to_non_nullable
              as String?,
      enableMediaInfo: null == enableMediaInfo
          ? _value.enableMediaInfo
          : enableMediaInfo // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_RadarrMediaManagementConfigCopyWith<$Res>
    implements $RadarrMediaManagementConfigCopyWith<$Res> {
  factory _$$_RadarrMediaManagementConfigCopyWith(
          _$_RadarrMediaManagementConfig value,
          $Res Function(_$_RadarrMediaManagementConfig) then) =
      __$$_RadarrMediaManagementConfigCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int id,
      bool autoUnmonitorPreviouslyDownloadedMovies,
      String? recycleBin,
      int recycleBinCleanupDays,
      RadarrProperDownloadType downloadPropersAndRepacks,
      bool createEmptyMovieFolders,
      bool deleteEmptyFolders,
      RadarrFileDateType fileDate,
      RadarrRescanAfterRefreshType rescanAfterRefresh,
      bool autoRenameFolders,
      bool pathsDefaultStatic,
      bool setPermissionsLinux,
      String? chmodFolder,
      String? chownGroup,
      bool skipFreeSpaceCheckWhenImporting,
      int minimumFreeSpaceWhenImporting,
      bool copyUsingHardlinks,
      bool importExtraFiles,
      String? extraFileExtensions,
      bool enableMediaInfo});
}

/// @nodoc
class __$$_RadarrMediaManagementConfigCopyWithImpl<$Res>
    extends _$RadarrMediaManagementConfigCopyWithImpl<$Res,
        _$_RadarrMediaManagementConfig>
    implements _$$_RadarrMediaManagementConfigCopyWith<$Res> {
  __$$_RadarrMediaManagementConfigCopyWithImpl(
      _$_RadarrMediaManagementConfig _value,
      $Res Function(_$_RadarrMediaManagementConfig) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? autoUnmonitorPreviouslyDownloadedMovies = null,
    Object? recycleBin = freezed,
    Object? recycleBinCleanupDays = null,
    Object? downloadPropersAndRepacks = null,
    Object? createEmptyMovieFolders = null,
    Object? deleteEmptyFolders = null,
    Object? fileDate = null,
    Object? rescanAfterRefresh = null,
    Object? autoRenameFolders = null,
    Object? pathsDefaultStatic = null,
    Object? setPermissionsLinux = null,
    Object? chmodFolder = freezed,
    Object? chownGroup = freezed,
    Object? skipFreeSpaceCheckWhenImporting = null,
    Object? minimumFreeSpaceWhenImporting = null,
    Object? copyUsingHardlinks = null,
    Object? importExtraFiles = null,
    Object? extraFileExtensions = freezed,
    Object? enableMediaInfo = null,
  }) {
    return _then(_$_RadarrMediaManagementConfig(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      autoUnmonitorPreviouslyDownloadedMovies: null ==
              autoUnmonitorPreviouslyDownloadedMovies
          ? _value.autoUnmonitorPreviouslyDownloadedMovies
          : autoUnmonitorPreviouslyDownloadedMovies // ignore: cast_nullable_to_non_nullable
              as bool,
      recycleBin: freezed == recycleBin
          ? _value.recycleBin
          : recycleBin // ignore: cast_nullable_to_non_nullable
              as String?,
      recycleBinCleanupDays: null == recycleBinCleanupDays
          ? _value.recycleBinCleanupDays
          : recycleBinCleanupDays // ignore: cast_nullable_to_non_nullable
              as int,
      downloadPropersAndRepacks: null == downloadPropersAndRepacks
          ? _value.downloadPropersAndRepacks
          : downloadPropersAndRepacks // ignore: cast_nullable_to_non_nullable
              as RadarrProperDownloadType,
      createEmptyMovieFolders: null == createEmptyMovieFolders
          ? _value.createEmptyMovieFolders
          : createEmptyMovieFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      deleteEmptyFolders: null == deleteEmptyFolders
          ? _value.deleteEmptyFolders
          : deleteEmptyFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      fileDate: null == fileDate
          ? _value.fileDate
          : fileDate // ignore: cast_nullable_to_non_nullable
              as RadarrFileDateType,
      rescanAfterRefresh: null == rescanAfterRefresh
          ? _value.rescanAfterRefresh
          : rescanAfterRefresh // ignore: cast_nullable_to_non_nullable
              as RadarrRescanAfterRefreshType,
      autoRenameFolders: null == autoRenameFolders
          ? _value.autoRenameFolders
          : autoRenameFolders // ignore: cast_nullable_to_non_nullable
              as bool,
      pathsDefaultStatic: null == pathsDefaultStatic
          ? _value.pathsDefaultStatic
          : pathsDefaultStatic // ignore: cast_nullable_to_non_nullable
              as bool,
      setPermissionsLinux: null == setPermissionsLinux
          ? _value.setPermissionsLinux
          : setPermissionsLinux // ignore: cast_nullable_to_non_nullable
              as bool,
      chmodFolder: freezed == chmodFolder
          ? _value.chmodFolder
          : chmodFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      chownGroup: freezed == chownGroup
          ? _value.chownGroup
          : chownGroup // ignore: cast_nullable_to_non_nullable
              as String?,
      skipFreeSpaceCheckWhenImporting: null == skipFreeSpaceCheckWhenImporting
          ? _value.skipFreeSpaceCheckWhenImporting
          : skipFreeSpaceCheckWhenImporting // ignore: cast_nullable_to_non_nullable
              as bool,
      minimumFreeSpaceWhenImporting: null == minimumFreeSpaceWhenImporting
          ? _value.minimumFreeSpaceWhenImporting
          : minimumFreeSpaceWhenImporting // ignore: cast_nullable_to_non_nullable
              as int,
      copyUsingHardlinks: null == copyUsingHardlinks
          ? _value.copyUsingHardlinks
          : copyUsingHardlinks // ignore: cast_nullable_to_non_nullable
              as bool,
      importExtraFiles: null == importExtraFiles
          ? _value.importExtraFiles
          : importExtraFiles // ignore: cast_nullable_to_non_nullable
              as bool,
      extraFileExtensions: freezed == extraFileExtensions
          ? _value.extraFileExtensions
          : extraFileExtensions // ignore: cast_nullable_to_non_nullable
              as String?,
      enableMediaInfo: null == enableMediaInfo
          ? _value.enableMediaInfo
          : enableMediaInfo // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RadarrMediaManagementConfig implements _RadarrMediaManagementConfig {
  const _$_RadarrMediaManagementConfig(
      {required this.id,
      required this.autoUnmonitorPreviouslyDownloadedMovies,
      this.recycleBin,
      required this.recycleBinCleanupDays,
      required this.downloadPropersAndRepacks,
      required this.createEmptyMovieFolders,
      required this.deleteEmptyFolders,
      required this.fileDate,
      required this.rescanAfterRefresh,
      required this.autoRenameFolders,
      required this.pathsDefaultStatic,
      required this.setPermissionsLinux,
      this.chmodFolder,
      this.chownGroup,
      required this.skipFreeSpaceCheckWhenImporting,
      required this.minimumFreeSpaceWhenImporting,
      required this.copyUsingHardlinks,
      required this.importExtraFiles,
      this.extraFileExtensions,
      required this.enableMediaInfo});

  factory _$_RadarrMediaManagementConfig.fromJson(Map<String, dynamic> json) =>
      _$$_RadarrMediaManagementConfigFromJson(json);

  @override
  final int id;
  @override
  final bool autoUnmonitorPreviouslyDownloadedMovies;
  @override
  final String? recycleBin;
  @override
  final int recycleBinCleanupDays;
  @override
  final RadarrProperDownloadType downloadPropersAndRepacks;
  @override
  final bool createEmptyMovieFolders;
  @override
  final bool deleteEmptyFolders;
  @override
  final RadarrFileDateType fileDate;
  @override
  final RadarrRescanAfterRefreshType rescanAfterRefresh;
  @override
  final bool autoRenameFolders;
  @override
  final bool pathsDefaultStatic;
  @override
  final bool setPermissionsLinux;
  @override
  final String? chmodFolder;
  @override
  final String? chownGroup;
  @override
  final bool skipFreeSpaceCheckWhenImporting;
  @override
  final int minimumFreeSpaceWhenImporting;
  @override
  final bool copyUsingHardlinks;
  @override
  final bool importExtraFiles;
  @override
  final String? extraFileExtensions;
  @override
  final bool enableMediaInfo;

  @override
  String toString() {
    return 'RadarrMediaManagementConfig(id: $id, autoUnmonitorPreviouslyDownloadedMovies: $autoUnmonitorPreviouslyDownloadedMovies, recycleBin: $recycleBin, recycleBinCleanupDays: $recycleBinCleanupDays, downloadPropersAndRepacks: $downloadPropersAndRepacks, createEmptyMovieFolders: $createEmptyMovieFolders, deleteEmptyFolders: $deleteEmptyFolders, fileDate: $fileDate, rescanAfterRefresh: $rescanAfterRefresh, autoRenameFolders: $autoRenameFolders, pathsDefaultStatic: $pathsDefaultStatic, setPermissionsLinux: $setPermissionsLinux, chmodFolder: $chmodFolder, chownGroup: $chownGroup, skipFreeSpaceCheckWhenImporting: $skipFreeSpaceCheckWhenImporting, minimumFreeSpaceWhenImporting: $minimumFreeSpaceWhenImporting, copyUsingHardlinks: $copyUsingHardlinks, importExtraFiles: $importExtraFiles, extraFileExtensions: $extraFileExtensions, enableMediaInfo: $enableMediaInfo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RadarrMediaManagementConfig &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.autoUnmonitorPreviouslyDownloadedMovies, autoUnmonitorPreviouslyDownloadedMovies) ||
                other.autoUnmonitorPreviouslyDownloadedMovies ==
                    autoUnmonitorPreviouslyDownloadedMovies) &&
            (identical(other.recycleBin, recycleBin) ||
                other.recycleBin == recycleBin) &&
            (identical(other.recycleBinCleanupDays, recycleBinCleanupDays) ||
                other.recycleBinCleanupDays == recycleBinCleanupDays) &&
            (identical(other.downloadPropersAndRepacks, downloadPropersAndRepacks) ||
                other.downloadPropersAndRepacks == downloadPropersAndRepacks) &&
            (identical(other.createEmptyMovieFolders, createEmptyMovieFolders) ||
                other.createEmptyMovieFolders == createEmptyMovieFolders) &&
            (identical(other.deleteEmptyFolders, deleteEmptyFolders) ||
                other.deleteEmptyFolders == deleteEmptyFolders) &&
            (identical(other.fileDate, fileDate) ||
                other.fileDate == fileDate) &&
            (identical(other.rescanAfterRefresh, rescanAfterRefresh) ||
                other.rescanAfterRefresh == rescanAfterRefresh) &&
            (identical(other.autoRenameFolders, autoRenameFolders) ||
                other.autoRenameFolders == autoRenameFolders) &&
            (identical(other.pathsDefaultStatic, pathsDefaultStatic) ||
                other.pathsDefaultStatic == pathsDefaultStatic) &&
            (identical(other.setPermissionsLinux, setPermissionsLinux) ||
                other.setPermissionsLinux == setPermissionsLinux) &&
            (identical(other.chmodFolder, chmodFolder) ||
                other.chmodFolder == chmodFolder) &&
            (identical(other.chownGroup, chownGroup) ||
                other.chownGroup == chownGroup) &&
            (identical(other.skipFreeSpaceCheckWhenImporting, skipFreeSpaceCheckWhenImporting) ||
                other.skipFreeSpaceCheckWhenImporting ==
                    skipFreeSpaceCheckWhenImporting) &&
            (identical(other.minimumFreeSpaceWhenImporting, minimumFreeSpaceWhenImporting) ||
                other.minimumFreeSpaceWhenImporting ==
                    minimumFreeSpaceWhenImporting) &&
            (identical(other.copyUsingHardlinks, copyUsingHardlinks) ||
                other.copyUsingHardlinks == copyUsingHardlinks) &&
            (identical(other.importExtraFiles, importExtraFiles) ||
                other.importExtraFiles == importExtraFiles) &&
            (identical(other.extraFileExtensions, extraFileExtensions) ||
                other.extraFileExtensions == extraFileExtensions) &&
            (identical(other.enableMediaInfo, enableMediaInfo) ||
                other.enableMediaInfo == enableMediaInfo));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        autoUnmonitorPreviouslyDownloadedMovies,
        recycleBin,
        recycleBinCleanupDays,
        downloadPropersAndRepacks,
        createEmptyMovieFolders,
        deleteEmptyFolders,
        fileDate,
        rescanAfterRefresh,
        autoRenameFolders,
        pathsDefaultStatic,
        setPermissionsLinux,
        chmodFolder,
        chownGroup,
        skipFreeSpaceCheckWhenImporting,
        minimumFreeSpaceWhenImporting,
        copyUsingHardlinks,
        importExtraFiles,
        extraFileExtensions,
        enableMediaInfo
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RadarrMediaManagementConfigCopyWith<_$_RadarrMediaManagementConfig>
      get copyWith => __$$_RadarrMediaManagementConfigCopyWithImpl<
          _$_RadarrMediaManagementConfig>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RadarrMediaManagementConfigToJson(
      this,
    );
  }
}

abstract class _RadarrMediaManagementConfig
    implements RadarrMediaManagementConfig {
  const factory _RadarrMediaManagementConfig(
      {required final int id,
      required final bool autoUnmonitorPreviouslyDownloadedMovies,
      final String? recycleBin,
      required final int recycleBinCleanupDays,
      required final RadarrProperDownloadType downloadPropersAndRepacks,
      required final bool createEmptyMovieFolders,
      required final bool deleteEmptyFolders,
      required final RadarrFileDateType fileDate,
      required final RadarrRescanAfterRefreshType rescanAfterRefresh,
      required final bool autoRenameFolders,
      required final bool pathsDefaultStatic,
      required final bool setPermissionsLinux,
      final String? chmodFolder,
      final String? chownGroup,
      required final bool skipFreeSpaceCheckWhenImporting,
      required final int minimumFreeSpaceWhenImporting,
      required final bool copyUsingHardlinks,
      required final bool importExtraFiles,
      final String? extraFileExtensions,
      required final bool enableMediaInfo}) = _$_RadarrMediaManagementConfig;

  factory _RadarrMediaManagementConfig.fromJson(Map<String, dynamic> json) =
      _$_RadarrMediaManagementConfig.fromJson;

  @override
  int get id;
  @override
  bool get autoUnmonitorPreviouslyDownloadedMovies;
  @override
  String? get recycleBin;
  @override
  int get recycleBinCleanupDays;
  @override
  RadarrProperDownloadType get downloadPropersAndRepacks;
  @override
  bool get createEmptyMovieFolders;
  @override
  bool get deleteEmptyFolders;
  @override
  RadarrFileDateType get fileDate;
  @override
  RadarrRescanAfterRefreshType get rescanAfterRefresh;
  @override
  bool get autoRenameFolders;
  @override
  bool get pathsDefaultStatic;
  @override
  bool get setPermissionsLinux;
  @override
  String? get chmodFolder;
  @override
  String? get chownGroup;
  @override
  bool get skipFreeSpaceCheckWhenImporting;
  @override
  int get minimumFreeSpaceWhenImporting;
  @override
  bool get copyUsingHardlinks;
  @override
  bool get importExtraFiles;
  @override
  String? get extraFileExtensions;
  @override
  bool get enableMediaInfo;
  @override
  @JsonKey(ignore: true)
  _$$_RadarrMediaManagementConfigCopyWith<_$_RadarrMediaManagementConfig>
      get copyWith => throw _privateConstructorUsedError;
}
